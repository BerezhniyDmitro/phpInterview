## Принципы хорошей архитектуры

## SOLID

- **Принцип единственной ответственности (Single responsibility)** - Мо­дуль дол­жен иметь од­ну и толь­ко од­ну при­чину для из­ме­нения. Мо­дуль дол­жен от­ве­чать за од­но­го и толь­ко за од­но­го актора (поль­зо­вате­ля или за­ин­те­ресо­ван­ное ли­цо).
- **Принцип открытости/закрытости (Open-closed)** - Прог­рам­мные сущ­ности дол­жны быть от­кры­ты для рас­ши­рения и зак­ры­ты для из­ме­нения.
- **Принцип подстановки Барбары Лисков (Liskov substitution)** - замена объектов их наследниками не должна нарушать работу программы.(У наследника -  типы принимаемыех параметров должны быть не уже, возарщаемых не шире + должны соранятся инварианты).
- **Принцип разделения интерфейса (Interface segregation)** - Много специализированных интерфейсов лучше, чем один универсальный - нужно "зависеть" только от того, что действительно нужно.
- **Принцип инверсии зависимостей (Dependency Invertion)** - на­ибо­лее гиб­ки­ми по­луча­ют­ся сис­те­мы, в которых за­виси­мос­ти в ис­ходном ко­де нап­равле­ны на абс­трак­ции, а не на кон­крет­ные ре­али­зации.

## GRASP

**GRASP** (general responsibility assignment software patterns — общие шаблоны распределения обязанностей; также существует английское слово "grasp" — «контроль, хватка») — шаблоны, используемые в объектно-ориентированном проектировании для решения общих задач по назначению обязанностей классам и объектам.

**1. Информационный эксперт** (Information Expert) Шаблон определяет базовый принцип распределения обязанностей:

Обязанность должна быть назначена тому, кто владеет максимумом необходимой информации для исполнения — информационному эксперту.

Этот шаблон — самый очевидный и важный из девяти. Если его не учесть — получится спагетти-код, в котором трудно разобраться.

Локализация же обязанностей, проводимая согласно шаблону:

- Повышает:
- Инкапсуляцию;
- Простоту восприятия;
- Готовность компонентов к повторному использованию;
- Снижает: степень зацеплений.

**2\. Создатель (Creator)**

- Класс должен создавать экземпляры тех классов, которые он может:
- Содержать или агрегировать;
- Записывать;
- Использовать;
- Инициализировать, имея нужные данные.

Так применяется шаблон «Информационный эксперт» (смотрите пункт №1) в вопросах создания объектов.

Альтернатива — шаблон «Фабрика» (создание объектов концентрируется в отдельном классе).

**3. Контроллер (Controller)**

Отвечает за операции, запросы на которые приходят от пользователя, и может выполнять сценарии одного или нескольких вариантов использования (например, создание и удаление) Не выполняет работу самостоятельно, а делегирует компетентным исполнителям;

Может представлять собой:

- Систему в целом;

- Подсистему;

- Корневой объект;

- Устройство.

**4. Слабое зацепление** (Low Coupling)

«Степень зацепления» (сопряжения\[2\]) — мера неотрывности элемента от других элементов (либо мера данных, имеющихся у него о них).

«Слабое» зацепление — распределение обязанностей и данных, обеспечивающее взаимную независимость классов. Класс со «слабым» зацеплением:

- Не зависит от внешних изменений;
- Прост для повторного использования.

**5. Высокая степень связности** (High Cohesion)

Предметные области следует разделять по классам.

Связность класса — мера подобия предметных областей его методов:

«Высокая» степень — сфокусированные подсистемы (предметная область определена, управляема и понятна);

«Низкая» степень — абстрактные подсистемы. Затруднены:

- Восприятие;
- Повторное использование;
- Поддержка;
- Устойчивость к внешним изменениям.

**6. Полиморфизм** (Polymorphism)

Устройство и поведение системы:

- Определяется данными;
- Задано полиморфными операциями её интерфейса.

Пример: Адаптация коммерческой системы к многообразию систем учёта налогов может быть обеспечена через внешний интерфейс объектов-адаптеров (смотрите также: Шаблон «Адаптеры»).

**7. Чистая выдумка** (Pure Fabrication)

Не относится к предметной области, но:

- Уменьшает зацепление;
- Повышает связность;
- Упрощает повторное использование.

«Pure Fabrication» отражает концепцию сервисов в модели проблемно-ориентированного проектирования.

Пример задачи: Не используя средства класса «А», внести его объекты в базу данных.

Решение: Создать класс «Б» для записи объектов класса «А» (смотрите также: «Data Access Object»).

**8. Посредник (Indirection)**

См. также: Посредник (шаблон проектирования)

Слабое зацепление между элементами системы (и возможность повторного использования) обеспечивается назначением промежуточного объекта их посредником.

Пример: В архитектуре Model-View-Controller, контроллер (англ. controller) ослабляет зацепление данных (англ. model) за их представление (англ. view).

**9. Устойчивость к изменениям (Protected Variations)**

Шаблон защищает элементы от изменения другими элементами (объектами или подсистемами) с помощью вынесения взаимодействия в фиксированный интерфейс, через который (и только через который) возможно взаимодействие между элементами. Поведение может варьироваться лишь через создание другой реализации интерфейса.

## Закон Деметры

Говоря упрощённо, каждый программный модуль:

- должен обладать ограниченным знанием о других модулях: знать о модулях, которые имеют «непосредственное» отношение к этому модулю.
- должен взаимодействовать только с известными ему модулями «друзьями», не взаимодействовать с незнакомцами.
- обращаться только к непосредственным «друзьям».

Аналогия из жизни: Если Вы хотите, чтобы собака побежала, глупо командовать её лапами, лучше отдать команду собаке, а она уже разберётся со своими лапами сама.

Основной идеей является то, что объект должен иметь как можно меньше представления о структуре и свойствах чего угодно (включая собственные подкомпоненты).

Общее описание правила: *Объект A не должен иметь возможность получить непосредственный доступ к объекту C, если у объекта A есть доступ к объекту B и у объекта B есть доступ к объекту C*.

Более формально, Закон Деметры для функций требует, что метод М объекта О должен вызывать методы только следующих типов объектов:

- собственно самого О
- параметров М
- других объектов, созданных в рамках М
- прямых компонентных объектов О
- глобальных переменных, доступных О, в пределах М

Практически, объект-клиент должен избегать вызовов методов объектов, внутренних членов, возвращенных методом объекта-сервиса.