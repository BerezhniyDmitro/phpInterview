# DDD

**Предметно-ориентированное проектирование** (реже проблемно-ориентированное, [англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA) Domain-driven design, DDD) — это набор принципов и схем, направленных на создание оптимальных систем объектов. Сводится к созданию программных абстракций, которые называются моделями [предметных областей](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%BC%D0%B5%D1%82%D0%BD%D0%B0%D1%8F_%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C). В эти модели входит [бизнес-логика](https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D0%B7%D0%BD%D0%B5%D1%81-%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B0), устанавливающая связь между реальными условиями области применения продукта и кодом.

Предметно-ориентированное проектирование не является какой-либо конкретной технологией или методологией. DDD — это набор правил, которые позволяют принимать правильные проектные решения. Данный подход позволяет значительно ускорить процесс [проектирования программного обеспечения](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D1%8F) в незнакомой предметной области.

### Стратегическое проектирование

Проектирование без технических реализаций, осуществляемое всей командой - как менеджерами/заказчиками, так и техническими специалистами.

Ubiquitous Language (Единый язык)

Bounded Context (Ограниченный контекст)

Core Domain (Смысловое ядро)

### Тактическое проектирвоание

Исплоьзование технических, структурных паттернов в вашем коде, для отражения результатов стратегического проектирования непосредственно в коде.

**Entity** Если какое-то понятие предметной области является уникальным и отличным от всех других объектов в системе, то для его моделирования используется `сущность`. Такие `объекты-сущности` могут сильно отличаться своей формой за весь цикл существования, тем не менее их всегда можно однозначно идентифицировать и найти по запросу. Для этого используются уникальные идентификаторы, создание которых необходимо продумать в первую очередь при проектировании `сущности`.

**Aggregate Root**

**Value Object** Если для объекта не важна индивидуальность, если он полностью определяется своими атрибутами, его следует считать `объектом-значением`. Чтобы выяснить, является ли какое-то понятие `значением`, необходимо выяснить, обладает ли оно большинством из следующих характеристик:

**Service**

**Domain Event**

**Module**

**Factory**

**Repository**

**Application Layer**

**Дополнительное чтение**:

- [DDD: стратегическое проектирование](https://habr.com/post/316438/)
- [DDD: тактическое проектирование](https://habr.com/post/316890/)
- [Ключевые концепции DDD](http://sergeyteplyakov.blogspot.com/2014/02/ddd.html)
- [Domain Driven Design на практике](https://habr.com/post/334126/)
- [DDD: Domain Driven Design](https://habr.com/post/61524/)

## Command and Query Responsibility Segregation (CQRS)

***CQRS*** – подход проектирования программного обеспечения, при котором код, изменяющий состояние, отделяется от кода, просто читающего это состояние. Подобное разделение может быть логическим и основываться на разных уровнях. Кроме того, оно может быть физическим и включать разные звенья (tiers), или уровни.

В основе этого подхода лежит принцип **Command-query separation** (CQS).

Основная идея CQS в том, что в объекте методы могут быть двух типов:
Queries: Методы возвращают результат, не изменяя состояние объекта. Другими словами, у Query не никаких побочных эффектов.
Commands: Методы изменяют состояние объекта, не возвращая значение.

## Event Driven

**Архитектура, управляемая событиями** ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA) event-driven architecture, EDA) архитектура, в осное которой лежит создание, определение, потребление и реакции на [события](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B5_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)). Т.е любое изменение в системы должно выбрасывать событие, на которое могут реагирвоать другие части системы.

## Event Sourcing

Идея *Event sourcing (ES)* заключается в том, что любому изменению модели можно сопоставить какое-то бизнес-событие, и сохранение всех событий является достаточным для того, чтобы каждый раз заново воспроизвести то же состояние модели.

В качестве примера можно привести риплеи игр: любой риплей обязан как минимум хранить в каком-то виде набор событий, которые генерировали сами игроки (отправил персонажа в такую-то точку, выстрелил в такую-то, купил такой-то предмет и т.д.), а уже последствия от этих действий всегда могут быть заново вычислены при условии, что игра детерминирована, т.е. она гаратинтирует, что игра будет развиваться точно также, как изначально (для псевдослучайных внутриигровых событий сохраняется seed и «случайный» элемент выполняется вполне себе неслучайно). С этой точки зрения всё, что происходит в игре — это заново вычисляемое состояние, включая смерти персонажей от потери здоровья. 
Также примером может служить баланс счета на банковском аккаунте, который формируется из совокупности всех операций зачисления и снятия денег со счёта.