Популярные архитектуры:

**Layered Architecture**(Слоистая) - делим на слои, самый нижний слой инфраструктура.

**Onion architecture**(Луковая)- слоистая с примененной инверсией зависимостей

**Hexagonal Architecture**(Гексогональная) - почти тоже что и луковая, но + некоторео разделение внттури слоёв.



## Command and Query Responsibility Segregation (CQRS)

***CQRS*** – подход проектирования программного обеспечения, при котором код, изменяющий состояние, отделяется от кода, просто читающего это состояние. Подобное разделение может быть логическим и основываться на разных уровнях. Кроме того, оно может быть физическим и включать разные звенья (tiers), или уровни.

В основе этого подхода лежит принцип **Command-query separation** (CQS). Основная идея CQS в том, что в объекте методы могут быть двух типов:

- *Commands*: Методы изменяют состояние объекта, не возвращая значение.
- *Queries*: Методы возвращают результат, не изменяя состояние объекта. Другими словами, у Query не никаких побочных эффектов.

## Event Driven

**Архитектура, управляемая событиями** ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA) event-driven architecture, EDA) архитектура, в осное которой лежит создание, определение, потребление и реакции на [события](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B5_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)). Т.е любое изменение в системы должно выбрасывать событие, на которое могут реагирвоать другие части системы.

## Event Sourcing

Идея `Event sourcing (ES)`заключается в том, что любому изменению модели можно сопоставить какое-то бизнес-событие, и сохранение всех событий является достаточным для того, чтобы каждый раз заново воспроизвести то же состояние модели.

В качестве примера можно привести риплеи игр: любой риплей обязан как минимум хранить в каком-то виде набор событий, которые генерировали сами игроки (отправил персонажа в такую-то точку, выстрелил в такую-то, купил такой-то предмет и т.д.), а уже последствия от этих действий всегда могут быть заново вычислены при условии, что игра детерминирована, т.е. она гаратинтирует, что игра будет развиваться точно также, как изначально (для псевдослучайных внутриигровых событий сохраняется seed и «случайный» элемент выполняется вполне себе неслучайно). С этой точки зрения всё, что происходит в игре — это заново вычисляемое состояние, включая смерти персонажей от потери здоровья. 
Также примером может служить баланс счета на банковском аккаунте, который формируется из совокупности всех операций зачисления и снятия денег со счёта.

## Inversion of Control, Dependency Inversion, Dependency Injection

Инверсия управления (**IoC, Inversion of Control)** – это достаточно общее понятие, которое отличает библиотеку от фреймворка. Классическая модель подразумевает, что вызывающий код контролирует внешнее окружение и время и порядок вызова библиотечных методов. Однако в случае фреймворка обязанности меняются местами: фреймворк предоставляет некоторые точки расширения, через которые он вызывает определенные методы пользовательского кода. 

Инверсия управления в ооп, иначе инверсия зависимостей(**DI,dependency inversion**)— важный принцип объектно-ориентированного программирования, используемый для уменьшения coupling в компьютерных программах. Есть два паттерна реализации DI:

- Суть паттерна **Service Locator**  сводится к тому, что вместо создания конкретных объектов («сервисов») напрямую с помощью ключевого слова **new**, мы будем использовать специальный «фабричный» объект, который будет отвечать за инициализацию и предоставление всех сервисов.
- **Внедрение зависимости** ( Dependency injection, DI) — Внедрение зависимостей (DI, Dependency Injection) – это механизм передачи классу его зависимостей. Существует несколько конкретных видов или паттернов внедрения зависимостей: внедрение зависимости через конструктор ([Constructor Injection](http://sergeyteplyakov.blogspot.com/2012/12/di-constructor-injection.html)), через метод ([Method Injection](http://sergeyteplyakov.blogspot.com/2013/02/di-method-injection.html)) и через свойство ([Property Injection](http://sergeyteplyakov.blogspot.com/2013/01/di-property-injection.html)). В полном соответствии с принципом единой обязанности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму,  и не дергает никаких контейнеров/фабрик/реестров для получения нужных сервисов самостоятельно(в этом ключевое отличие от **Service Locator**).

**Dependency Inversion Principe(DIP)**

Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракции.Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

