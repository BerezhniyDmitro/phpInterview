# PHP Internals

## Zval

Структура данных zval (сокращение от "Zend value") используется для представления любых значений PHP. Это одна из самых важных структур во всем PHP и вы будете много работать с ней. 

Zval хранит некоторое значение и тип этого значения. Это необходимо потому что PHP — это язык с динамической типизацией и поэтому тип переменных известен только во время выполнения программы (run-time), а не во время компиляции (compile-time). Кроме того, тип переменной может быть изменен в течение жизни zval, то есть zval ранее хранимый как целое число (integer) позднее может содержать строку (string).

Тип переменной хранится как целочисленная метка (type tag, unsigned char). Метка может принимать одно из 8 значений, которое соответствует 8 типам данных доступных в PHP. Эти значения должны присваиваться с использованием констант вида `IS_TYPE`. Например, `IS_NULL`соответствует типу данных null, а `IS_STRING` — строке.

### zval’ы в PHP 5

Структура zval в пятой версии выглядит так:

```C
typedef struct _zval_struct {
    zvalue_value value;
    zend_uint refcount__gc;
    zend_uchar type;
    zend_uchar is_ref__gc;
} zval;
```

Как видите, конструкция включает в себя value, type и дополнительную информацию __gc, о чём я расскажу ниже. Value представляет собой объединение различных возможных значений, которые может хранить zval:

```
typedef union _zvalue_value {
    long lval;                 // Для булевых, целочисленных и ресурсов
    double dval;               // Для чисел с плавающей запятой
    struct {                   // Для строковых
        char *val;
        int len;
    } str;
    HashTable *ht;             // Для массивов
    zend_object_value obj;     // Для объектов
    zend_ast *ast;             // Для констант
} zvalue_value;
```

Объединение в языке С – это структура, в которой лишь один компонент может быть активен в данный момент времени, и размер которой равен размеру самого большого компонента. Все компоненты объединения хранятся в памяти в одном месте и могут интерпретироваться по-разному, в зависимости от того, к кому из них вы обращаетесь. Если считать lval, то его значение будет интерпретировано как знаковое целочисленное. Значение dval будет представлено в виде числа двойной точности с плавающей запятой. И так далее.Чтобы узнать, какой компонент объединения используется в данный момент, можно посмотреть текущее значение свойства type:

### Zval’ы в PHP 7

В седьмой версии языка мы получили новую реализацию zval. Одним из главных нововведений стало то, что zval больше не нужно отдельно размещать в куче. Также refcount теперь хранится не в самом zval, а в любом из комплексных значений, на которые он указывает — в строках, массивах или объектах. Это даёт следующие преимущества:

- Простые значения не требуют размещения в куче и не используют подсчёт ссылок.
- Больше нет никакого двойного подсчёта. В случае с объектами используется счётчик только внутри самого объекта.
- Поскольку refcount теперь хранится в самом значении, то оно может быть использовано независимо от самого zval. Например, строка может использоваться и в zval, и быть ключом в хэш-таблице.
- Теперь стало гораздо меньше указателей, которые нужно перебрать, чтобы получить значение.

Вот как выглядит структура нового zval:

```c
    zend_value value;
    union {
        struct {
            ZEND_ENDIAN_LOHI_4(
                zend_uchar type,
                zend_uchar type_flags,
                zend_uchar const_flags,
                zend_uchar reserved)
        } v;
        uint32_t type_info;
    } u1;
    union {
        uint32_t var_flags;
        uint32_t next;                 // hash collision chain
        uint32_t cache_slot;           // literal cache slot
        uint32_t lineno;               // line number (for ast nodes)
        uint32_t num_args;             // arguments number for EX(This)
        uint32_t fe_pos;               // foreach position
        uint32_t fe_iter_idx;          // foreach iterator index
    } u2;
};`
```


Первый компонент остался практически таким же, это объединение value. Второй компонент — целочисленный, хранящий информацию о типе, который с помощью объединения разбит на отдельные байты (можно игнорировать макрос ZEND_ENDIAN_LOHI_4, он нужен лишь для обеспечения консистентной структуры между платформами с разными порядками следования байтов). Важными частями этой вложенной конструкции являются type и type_flags, о них я расскажу ниже.

Также здесь есть одна небольшая проблема. Value занимает 8 байт, и благодаря своей структуре добавление даже одного байта повлечёт за собой увеличение размера zval на 16 байт. Но ведь нам не нужно целых 8 байт для хранения типа. Поэтому в zval есть дополнительное объединение u2, которое по умолчанию не используется, но может применяться для хранения 4 байт данных. Разные компоненты объединения предназначены для разных видов использования этого дополнительного хранилища.

## Устройство массивов
Конструкция хэш-таблицы
 - Ключ может быть строкой или целочисленным. В первом случае используется структура zend_string, во втором — zend_ulong.
 - Хэш-таблица всегда должна помнить порядок добавления её элементов.
 - Размер хэш-таблицы меняется автоматически. В зависимости от обстоятельств она самостоятельно уменьшается или увеличивается.
 - С точки зрения внутренней реализации размер таблицы всегда равен двойке в степени. Это делается для улучшения производительности и выравнивания размещения данных в памяти.
 - Все значения в хэш-таблице хранятся в структуре zval, больше нигде. Zval’ы могут содержать данные любых типов.

Рассмотрим структуру HashTable:
```
struct _zend_array {
    zend_refcounted_h gc;
    union {
        struct {
            ZEND_ENDIAN_LOHI_4(
                zend_uchar    flags,
                zend_uchar    nApplyCount,
                zend_uchar    nIteratorsCount,
                zend_uchar    reserve)
        } v;
        uint32_t flags;           /* доступно 32 флага */
    } u;
    uint32_t     nTableMask;       /* маска — nTableSize */
    Bucket      *arData;           /* полезное хранилище данных */
    uint32_t     nNumUsed;         /* следующая доступная ячейка в arData */
    uint32_t     nNumOfElements;   /* общее количество занятых элементов в arData */
    uint32_t     nTableSize;       /* размер таблицы, всегда равен двойке в степени */
    uint32_t     nInternalPointer; /* используется для итерации */
    zend_long    nNextFreeElement; /* следующий доступный целочисленный ключ */
    dtor_func_t  pDestructor;      /* деструктор данных */
};
```
Некоторые поля используются редко, и поэтому мы о них говорить не будем. 

Размер этой структуры — 56 байт (согласно модели LP64).

Самое интересное поле данных — arData, это своеобразный указатель на область памяти цепочки Bucket. Сама Bucket представляет собой одну ячейку в массиве:
```
typedef struct _Bucket {
    zval              val; /* значение */
    zend_ulong        h;   /* хэш (или числовой индекс)   */
    zend_string      *key; /* строковый ключ или NULL для числовых значений */
} Bucket;
```
Как вы могли заметить, в структуре Bucket будет храниться zval. Обратите внимание, что здесь используется не указатель на zval, а именно сама структура. Так сделано потому, что в РНР 7 zval’ы больше не размещаются в куче (в отличие от PHP 5), но при этом в РНР 7 может размещаться целевое значение, хранящееся в zval в виде указателя (например, строка РНР).

Давайте посмотрим на картинке, как происходит размещение в памяти:
https://hsto.org/files/c37/c27/e99/c37c27e990434db2bb258f4a98cc6855.png
Как видите, помещаемые в хэш-таблицу данные хранятся в смежном разделе памяти: arData.

PHP5

PHP7

## Устройство объектов

PHP5

PHP7


***Дополнительно:***

http://www.phpinternalsbook.com/

https://romka.gitbooks.io/php-internals-book-ru/

[Как устроены переменные в PHP](https://habr.com/post/162713/)

[Как устроены массивы в PHP](https://habr.com/post/162685/)

[Внутреннее представление значений в PHP7 (часть 1)](https://habr.com/company/mailru/blog/257999/)

[Внутреннее представление значений в PHP 7 (часть 2)](https://habr.com/company/mailru/blog/261131/)

[Массивы в РНР 7: хэш-таблицы](https://habr.com/company/mailru/blog/308240/)

[Подробно об объектах и классах в PHP](https://habr.com/company/mailru/blog/255237/)

[Объекты в PHP 7](https://habr.com/company/mailru/blog/275497/)

[Улучшение производительности PHP 7](https://habr.com/company/mailru/blog/318008/)

[Обзор расширения OPCache для PHP](https://habr.com/company/mailru/blog/310054/)

[Трамплин вызова магических функций в PHP 7](https://habr.com/company/mailru/blog/311068/)



https://habr.com/company/mailru/blog/318008/



https://habr.com/company/mailru/blog/308240/
