# PHP Internals

## Zval

Структура данных zval (сокращение от "Zend value") используется для представления любых значений PHP. Это одна из самых важных структур во всем PHP и вы будете много работать с ней. 

Zval хранит некоторое значение и тип этого значения. Это необходимо потому что PHP — это язык с динамической типизацией и поэтому тип переменных известен только во время выполнения программы (run-time), а не во время компиляции (compile-time). Кроме того, тип переменной может быть изменен в течение жизни zval, то есть zval ранее хранимый как целое число (integer) позднее может содержать строку (string).

Тип переменной хранится как целочисленная метка (type tag, unsigned char). Метка может принимать одно из 8 значений, которое соответствует 8 типам данных доступных в PHP. Эти значения должны присваиваться с использованием констант вида `IS_TYPE`. Например, `IS_NULL`соответствует типу данных null, а `IS_STRING` — строке.

### zval’ы в PHP 5

Структура zval в пятой версии выглядит так:

```C
typedef struct _zval_struct {
    zvalue_value value;
    zend_uint refcount__gc;
    zend_uchar type;
    zend_uchar is_ref__gc;
} zval;
```

Как видите, конструкция включает в себя value, type и дополнительную информацию __gc, о чём я расскажу ниже. Value представляет собой объединение различных возможных значений, которые может хранить zval:

```c
    long lval;                 // Для булевых, целочисленных и ресурсов
    double dval;               // Для чисел с плавающей запятой
    struct {                   // Для строковых
        char *val;
        int len;
    } str;
    HashTable *ht;             // Для массивов
    zend_object_value obj;     // Для объектов
    zend_ast *ast;             // Для констант
} zvalue_value;`
```

Объединение в языке С – это структура, в которой лишь один компонент может быть активен в данный момент времени, и размер которой равен размеру самого большого компонента. Все компоненты объединения хранятся в памяти в одном месте и могут интерпретироваться по-разному, в зависимости от того, к кому из них вы обращаетесь. Если считать lval, то его значение будет интерпретировано как знаковое целочисленное. Значение dval будет представлено в виде числа двойной точности с плавающей запятой. И так далее.Чтобы узнать, какой компонент объединения используется в данный момент, можно посмотреть текущее значение свойства type:

### Zval’ы в PHP 7

В седьмой версии языка мы получили новую реализацию zval. Одним из главных нововведений стало то, что zval больше не нужно отдельно размещать в куче. Также refcount теперь хранится не в самом zval, а в любом из комплексных значений, на которые он указывает — в строках, массивах или объектах. Это даёт следующие преимущества:

- Простые значения не требуют размещения в куче и не используют подсчёт ссылок.
- Больше нет никакого двойного подсчёта. В случае с объектами используется счётчик только внутри самого объекта.
- Поскольку refcount теперь хранится в самом значении, то оно может быть использовано независимо от самого zval. Например, строка может использоваться и в zval, и быть ключом в хэш-таблице.
- Теперь стало гораздо меньше указателей, которые нужно перебрать, чтобы получить значение.

Вот как выглядит структура нового zval:

```c
    zend_value value;
    union {
        struct {
            ZEND_ENDIAN_LOHI_4(
                zend_uchar type,
                zend_uchar type_flags,
                zend_uchar const_flags,
                zend_uchar reserved)
        } v;
        uint32_t type_info;
    } u1;
    union {
        uint32_t var_flags;
        uint32_t next;                 // hash collision chain
        uint32_t cache_slot;           // literal cache slot
        uint32_t lineno;               // line number (for ast nodes)
        uint32_t num_args;             // arguments number for EX(This)
        uint32_t fe_pos;               // foreach position
        uint32_t fe_iter_idx;          // foreach iterator index
    } u2;
};`
```


Первый компонент остался практически таким же, это объединение value. Второй компонент — целочисленный, хранящий информацию о типе, который с помощью объединения разбит на отдельные байты (можно игнорировать макрос ZEND_ENDIAN_LOHI_4, он нужен лишь для обеспечения консистентной структуры между платформами с разными порядками следования байтов). Важными частями этой вложенной конструкции являются type и type_flags, о них я расскажу ниже.

Также здесь есть одна небольшая проблема. Value занимает 8 байт, и благодаря своей структуре добавление даже одного байта повлечёт за собой увеличение размера zval на 16 байт. Но ведь нам не нужно целых 8 байт для хранения типа. Поэтому в zval есть дополнительное объединение u2, которое по умолчанию не используется, но может применяться для хранения 4 байт данных. Разные компоненты объединения предназначены для разных видов использования этого дополнительного хранилища.

## Устройство массивов

PHP5

PHP7

## Устройство объектов

PHP5

PHP7

***Дополнительно:***

http://www.phpinternalsbook.com/

https://romka.gitbooks.io/php-internals-book-ru/

https://habr.com/company/mailru/blog/310054/

https://habr.com/company/mailru/blog/311068/

https://habr.com/company/mailru/blog/318008/

https://habr.com/company/mailru/blog/257999/

https://m.habr.com/company/mailru/blog/261131/

https://habr.com/company/mailru/blog/308240/