# Mysql

## Движки таблиц MySql

###### MyIsam

###### InnoDB

###### Memory

Таблица, хранимая в памяти. Поддерживает хеш индекс. Может подойти для справочных» таблиц или таблиц «соответствия», например для таблицы, в которой почтовым кодам соответствуют названия регионов; Для кэширования результатов периодического агрегирования данных; для промежуточных результатов при анализе данных.

###### CSV

хранит таблицы в CSV формате
позволяет редактировать таблицы внешними приложениями
плохо документирован, есть открытые баги

###### FEDERATED

Представляет собой «прозрачное» подключение к другому серверу (не репликация). Есть множество ограничений, планируется возможность подключения к отличным от MySQL серверам.

###### BLACKHOLE

Данные идут «вникуда», двоичные логи пишуться. Оптимизация репликации (мастер-сервер не пишет данные на диск)

## Разное

### Explain

* **id** – порядковый номер для каждого SELECT’а внутри запроса (когда имеется несколько подзапросов)
* **select_type** – тип запроса SELECT.
  * **SIMPLE** — Простой запрос SELECT без подзапросов или UNION’ов
  * **PRIMARY** – данный SELECT – самый внешний запрос в JOIN’е
  * **DERIVED** – данный SELECT является частью подзапроса внутри FROM
  * **SUBQUERY** – первый SELECT в подзапросе
  * **DEPENDENT SUBQUERY** – подзапрос, который зависит от внешнего запроса
   * **UNCACHABLE SUBQUERY** – не кешируемый подзапрос (существуют определенные условия для того, чтобы запрос кешировался)
  * **UNION** – второй или последующий SELECT в UNION’е
  * **DEPENDENT UNION** – второй или последующий SELECT в UNION’е, зависимый от внешнего запроса
  * **UNION RESULT** – результат UNION’а
* **Table** – таблица, к которой относится выводимая строка
* **Type** — указывает на то, как MySQL связывает используемые таблицы. Это одно из наиболее полезных полей в выводе потому, что может сообщать об отсутствующих индексах или почему написанный запрос должен быть пересмотрен и переписан. Возможные значения:
  * **System** – таблица имеет только одну строку
  * **Const** – таблица имеет только одну соответствующую строку, которая проиндексирована. Это наиболее быстрый тип соединения потому, что таблица читается только один раз и значение строки может восприниматься при дальнейших соединениях   как константа.
  * **Eq_ref** – все части индекса используются для связывания. Используемые индексы: PRIMARY KEY или UNIQUE NOT NULL. Это еще один наилучший возможный тип связывания.
  * **Ref** – все соответствующие строки индексного столбца считываются для каждой комбинации строк из предыдущей таблицы. Этот тип соединения для индексированных столбцов выглядит как использование операторов = или < = >
  * **Fulltext** – соединение использует полнотекстовый индекс таблицы
  * **Ref_or_null** – то же самое, что и ref, но также содержит строки со значением null для столбца
  * **Index_merge** – соединение использует список индексов для получения результирующего набора. Столбец key вывода команды EXPLAIN будет содержать список использованных индексов.
  * **Unique_subquery** – подзапрос IN возвращает только один результат из таблицы и использует первичный ключ.
  * **Index_subquery** – тоже, что и предыдущий, но возвращает более одного результата.
  * **Range** – индекс, использованный для нахождения соответствующей строки в определенном диапазоне, обычно, когда ключевой столбец сравнивается с константой, используя операторы вроде: BETWEEN, IN, >, >=, etc.
  * **Index** – сканируется все дерево индексов для нахождения соответствующих строк.
  * **All** – Для нахождения соответствующих строк используются сканирование всей таблицы. Это наихудший тип соединения и обычно указывает на отсутствие подходящих индексов в таблице.
* **Possible_keys** – показывает индексы, которые могут быть использованы для нахождения строк в таблице. На практике они могут использоваться, а могут и не использоваться. Фактически, этот столбец может сослужить добрую службу в деле оптимизации запросов, т.к значение NULL указывает на то, что не найдено ни одного подходящего индекса .
* **Key**– указывает на использованный индекс. Этот столбец может содержать индекс, не указанный в столбце possible_keys. В процессе соединения таблиц оптимизатор ищет наилучшие варианты и может найти ключи, которые не отображены в possible_keys, но являются более оптимальными для использования.
* **Key_len** – длина индекса, которую оптимизатор MySQL выбрал для использования. Например, значение key_len, равное 4, означает, что памяти требуется для хранения 4 знаков.
* **Ref** – указываются столбцы или константы, которые сравниваются с индексом, указанным в поле key. MySQL выберет либо значение константы для сравнения, либо само поле, основываясь на плане выполнения запроса.
* **Rows** – отображает число записей, обработанных для получения выходных данных. Это еще одно очень важное поле, которое дает повод оптимизировать запросы, особенно те, которые используют JOIN’ы и подзапросы.
* **Extra** – содержит дополнительную информацию, относящуюся к плану выполнения запроса. Такие значения как “Using temporary”, “Using filesort” и т.д могут быть индикатором проблемного запроса. С полным списком возможных значений вы можете ознакомиться здесь

https://habr.com/post/211022/


### Char & Varchar
При выборе типов строк действует правило минимума. Оцените максимальную длину строки и поставьте ограничение. Тип **CHAR** — тип фиксированной длины. Это значит, что для любой строки будет выделено всегда одно и то же количество байт.
**VARCHAR** — тип переменной длины. В такой колонке строка будет занимать ровно свою длину (в количестве символов).
Однако Mysql прибавит еще 1 или 2 байта на хранение длины самой строки. Также стоит учесть, что обновление такой строки может быть дорогой операцией (чревато фрагментацией данных, а значит — замедлением чтения). Используйте такое правило:

**Если значения в текстовой колонке похожи по длине, выбирайте CHAR, иначе — VARCHAR.**

## Innodb VS MyIsam

- MyISAM поддерживает сжатие таблиц в отличии от InnoDB.

- MyISAM имеет встроенные полнотекстный поиск в отличии от InnoDB.
- InnoDB поддерживает транзакции в отличии от MyISAM.
- InnoDB поддерживает блокировки уровня строки (MyISAM - только уровня таблицы).
- InnoDB поддерживает ограничения внешних ключей (MyISAM - нет).
- InnoDB более надежна при больших объемах данных.
- InnoDB в теории немного быстрее.

<table border="1" width="100%" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="65%">Описание</td>
<td width="15%"><strong>MyISAM</strong></td>
<td width="20%"><strong>InnoDB</strong></td>
</tr>
<tr>
<td><strong>Транзакционный движек?</strong>Транзакция (Transaction) — блок операторов SQL , который в случае ошибки в одном запросе, возвращается к предыдущему состоянию (Rollback), и только в случае выполнения всех запросов подтверждается (Commit)</td>
<td>Нет</td>
<td>Да</td>
</tr>
<tr>
<td><strong>Поддержка внешних ключей</strong>Внешние ключи — это способ связать записи в двух таблицах по определенным полям так, что при обновлении поля в родительской автоматически происходит определенное изменение поля в дочерней (дочернюю и родительскую выбираешь при создании ключа; точнее, создаешь ключ в дочерней, который ссылается на родительскую).</td>
<td>Нет</td>
<td>Да</td>
</tr>
<tr>
<td><strong>Блокировка.</strong>Блокировка на уровне строк, т.е. если процессу нужно обновить строку в таблице, то он блокирует только эту строку, позволяя другим обновлять другие строки параллельно</td>
<td>Блокировка на уровне таблиц</td>
<td>Блокировка на уровне строк</td>
</tr>
<tr>
<td>Одновременные запросы к разным частям таблицы.</td>
<td>Медленнее</td>
<td>Быстрее</td>
</tr>
<tr>
<td>При смешанной нагрузке в таблице (select/update/delete/insert)</td>
<td>Медленнее</td>
<td>Быстрее</td>
</tr>
<tr>
<td>Операция Insert</td>
<td>Быстрее</td>
<td>Медленнее, ибо есть оверхед на транзакцию, но это цена надежности</td>
</tr>
<tr>
<td>Если преобладают операции чтения (SELECT)</td>
<td>Работает быстрее</td>
<td>Работает медленнее</td>
</tr>
<tr>
<td><strong>Deadlock</strong>Deadlock — ситуация в многозадачной среде или СУБД, при которой несколько процессов находятся в состоянии бесконечного ожидания ресурсов, захваченных самими этими процессами.</td>
<td>Не возникают</td>
<td>Возможны.</td>
</tr>
<tr>
<td>Поддержка полнотекстового поиска</td>
<td>Да</td>
<td>Нет (доступен начиная с версии MySQL 5.6.4)</td>
</tr>
<tr>
<td>Запрос Count(*)</td>
<td>Быстрее</td>
<td>Медленнее</td>
</tr>
<tr>
<td><strong>Поддержка mysqlhotcopy</strong>Утилита mysqlhotcopy представляет собой Perl-сценарий, использующий SQL-команды LOCK TABLES, FLUSH TABLES и Unix-утилиты cp или scp для быстрого получения резервной копии базы данных.</td>
<td>Да</td>
<td>Нет</td>
</tr>
<tr>
<td>Файловое хранение таблиц</td>
<td>Каждой таблице отдельный файл</td>
<td>Данные при настройках по умолчанию хранятся в больших совместно используемых файлах</td>
</tr>
<tr>
<td><strong>Бинарное копировании таблиц?</strong>Табличные файлы можно перемещать между компьютерами разных архитектур и разными операционными системами без всякого преобразования.</td>
<td>Да</td>
<td>Нет</td>
</tr>
<tr>
<td>Размер таблиц в БД</td>
<td>Меньше</td>
<td>Больше</td>
</tr>
<tr>
<td>Поведение в случае сбоя</td>
<td>Крашится вся таблица</td>
<td>По логам можно все восстановить</td>
</tr>
<tr>
<td>В случае хранения «логов» и подобного</td>
<td>Лучше</td>
<td>Хуже</td>
</tr>
</tbody>
</table>

## DATATIME vs TIMESTAMP
TIMESTAMP хранит значение равное количеству секунд, прошедших с полуночи 1 января 1970 года по усреднённому времени Гринвича. При получении из базы отображается с учётом часового пояса.Предназначен для хранения даты и/или времени происхождения неких событий. Важное отличие от DATATIME в диапазонах значений: очевидно, что TIMESTAMP не годится для хранения исторических событий (даже таких, как дни рождений), но отлично подходит для хранения текущих (логирование, даты размещения статей, добавления товаров, оформления заказов) и предстоящих в обозримом будущем событий (выходы новых версий, календари и планировщики и т.д).

Основное удобство использования типа TIMESTAMP состоит в том, что для столбцов этого типа в таблицах можно задавать значение по умолчанию в виде подстановки текущего времени, а так же установки текущего времени при обновлении записи. Если вам требуется эти возможности, то с вероятностью 99% TIMESTAMP — именно то, что вам нужно.

Не стоит бояться того, что с приближением к 2038 году ваш софт перестанет работать. Во-первых, до этого времени вашим софтом, скорее всего, просто перестанут пользоваться (особенно версиями, которые пишутся сейчас). Во-вторых, с приближением к этой дате разработчики MySQL обязательно что-нибудь придумают для сохранения работоспособности вашего софта. Все решится так же хорошо, как проблема Y2K.

Итак, тип TIMESTAMP используем для хранения дат и времени свершения событий нашего времени, а DATETIME и DATE — для хранения дат и времени свершения исторических событий, или событий глубокого будущего.

Диапазоны значений — это важное отличие между типами TIMESTAMP, DATETIME и DATE, но не главное. Главное то, что TIMESTAMP хранит значение в UTC. При сохранении значения оно переводится из текущего временной зоны в UTC, а при его чтении — во время текущей временной зоны из UTC. DATETIME и DATE хранят и выводят всегда одно и то же время, независимо от временных зон.

Временные зоны устанавливаются в СУБД MySQL глобально или для текущего подключения.Последнее можно использовать для обеспечения работы разных пользователей в разных временных зонах на уровне СУБД. Все значения времени физически будут храниться в UTC, а приниматься от клиента и отдаваться клинту — в значениях его временной зоны. Но только при использовании типа данных TIMESTAMP. DATE и DATETIME всегда принимают, хранят и отдают одно и то же значение.

Функция NOW() и ее синонимы возвращают значение времени в текущей временной зоне пользователя.

Учитывая все эти обстоятельства, необходимо быть крайне внимательными при изменении временной зоны в пределах подключения к серверу и использовании типов DATE и DATETIME. Если надо хранить дату (например, дату рождения), то никаких проблем не будет. Дата рождения в любой зоне одинаковая. Т.е. если вы родились 1 января в 0:00 UTC/GMT+0, то это не значит, что в Америке будут праздновать ваш день рождения 31 декабря. Но если вы решите хранить время события в столбце DATETIME, то тут уже построить работу с пользовательскими временными зонами на уровне СУБД просто не выйдет. 

DATETIME 8 байт
TIMESTAMP4 байта

## Является ли триггер частью транзакции?

For transactional tables, failure of a statement should cause rollback of all changes performed by the statement. Failure of a trigger causes the statement to fail, so trigger failure also causes rollback. For nontransactional tables, such rollback cannot be done, so although the statement fails, any changes performed prior to the point of the error remain in effect.


## Полезные ресурсы:
* https://ruhighload.com/%D0%92%D1%8B%D0%B1%D0%BE%D1%80+%D1%82%D0%B8%D0%BF%D0%BE%D0%B2+%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85+%D0%B2+mysql
* https://itif.ru/otlichiya-myisam-innodb/
* https://valera.ws/2009.09.17~time-formats-in-mysql/
* https://habr.com/company/mailru/blog/266811/


