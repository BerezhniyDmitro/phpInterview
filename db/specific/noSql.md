# noSql

## Memcached

[Memcached](http://code.google.com/p/memcached/) представляет собой сервер, хранящий в оперативной памяти некоторые данные с заданным временем жизни. Доступ к данным осуществляется по ключу (имени). Вы можете думать о Memcached, как о [хэш-таблице](https://eax.me/hash-tables/), хранящейся на сервере. Применяется он в основном для кэширования кода веб-страниц, результатов запросов к базе данных и тп.

Также ничто не мешает использовать Memcached в качестве «не очень надежного» key-value хранилища. Например, в нем можно хранить сессии пользователей, коды капч или счетчик посетителей, находящихся в данный момент на сайте.

## Redis

[Redis](http://redis.io/) (REmote DIctionary Server) — это *не*реляционная высокопроизводительная СУБД. Redis хранит все данные в памяти, доступ к данным осуществляется по ключу. Опционально копия данных может храниться на диске. Этот подход обеспечивает производительность, в десятки раз превосходящую производительность реляционных СУБД, а также упрощает секционирование (шардинг) данных.

### Коротко о главном

В первом приближении может показаться, что Redis мало чем отличается от [Memcached](https://eax.me/memcached/). И действительно, как Redis, так и Memcached хранят данные в памяти и осуществляют доступ к ним по ключу. Оба написаны на Си и распространяются под лицензией BSD. Но в действительности, между Redis и Memcahced больше различий, чем сходства.

В первую очередь, Redis умеет **сохранять данные на диск**. Можно настроить Redis так, чтобы данные вообще не сохранялись, сохранялись периодически по принципу copy-on-write, или сохранялись периодически *и* писались в журнал (binlog). Таким образом, всегда можно добиться требуемого баланса между производительностью и надежностью.

Redis, в отличие от Memcached, **позволяет хранить не только строки**, но и массивы (которые могут использоваться в качестве очередей или стеков), словари, множества без повторов, большие массивы бит (bitmaps), а также множества, отсортированные по некой величине. Разумеется, можно работать с отдельными элементами списков, словарей и множеств. Как и Memcached, Redis позволяет указать время жизни данных (двумя способами — «удалить тогда-то» и «удалить через …»). По умолчанию все данные хранятся вечно.

Интересная особенность Redis заключается в том, что это — **однопоточный сервер**. Такое решение сильно упрощает поддержку кода, обеспечивает атомарность операций и позволяет запустить по одному процессу Redis на каждое ядро процессора. Разумеется, каждый процесс будет прослушивать свой порт. Решение нетипичное, но вполне оправданное, так как на выполнение одной операции Redis тратит очень небольшое количество времени (порядка [*одной стотысячной* секунды](http://pyha.ru/wiki/index.php?title=Redis:benchmark)).

В Redis есть **репликация**. Репликация с несколькими главными серверами не поддерживается. Каждый подчиненный сервер может выступать в роли главного для других. Репликация в Redis не приводит к блокировкам ни на главном сервере, ни на подчиненных. На репликах разрешена операция записи. Когда главный и подчиненный сервер восстанавливают соединение после разрыва, происходит полная синхронизация (resync).

Также Redis поддерживает **транзакции** (будут последовательно выполнены либо все операции, либо ни одной) и **пакетную обработку команд** (выполняем пачку команд, затем получаем пачку результатов). Притом ничто не мешает использовать их совместно.

Еще одна особенность Redis — поддержка механизма **publish/subscribe**. С его помощью приложения могут создавать каналы, подписываться на них и помещать в каналы сообщения, которые будут получены всеми подписчиками. Что-то вроде [IRC-чатика](https://eax.me/irc-descr/).

Также хотелось бы отметить следующее:

- Redis очень прост (проще пареной репы! :) и прекрасно документирован;
- На данный момент длина ключа в Redis может составлять до 231 байт, длина строки — до 512 Мб, списки и множества могут содержать до 232элементов, один экземпляр Redis может хранить до 232 ключей;
- На одном сервере можно держать [несколько пронумерованных баз данных](http://rediscookbook.org/multiple_databases.html), по умолчанию их число равно 16-и.
- Приложения, использующие Redis, удобно профилировать (команда slowlog) и отлаживать (команда monitor);
- Redis написан таким образом, что резервную копию его базы данных можно сделать простым копированием файла дампа, даже во время работы сервера;
- Официально Windows не поддерживается, но есть неофициальные сборки Redis для Windows;
- Доступ к серверу можно защитить паролем;
- Разработка спонсируется компанией VMWare;
- В настоящее время ведется работа над [Redis Cluster](http://redis.io/topics/cluster-spec);
- Redis используется в Tumblr, Disqus, Skype, StackOverflow, Instagram, GitHub, Flickr, Digg [и много где еще](http://redis.io/topics/whos-using-redis);

Так для каких же целей можно использовать Redis?

### Области применения

Самое серьезное ограничение Redis заключается в том, что объем данных, который может хранится на одном физическом сервере, ограничен объемом оперативной памяти на этом сервере. Была предпринята попытка обойти это ограничение за счет использования виртуальной памяти, но эта идея [была признана неудачной](http://redis.io/topics/virtual-memory). Таким образом, хранить в Redis *много* данных стоит недешево.

Позволю себе привести цитату из The Little Redis Book:

> Это тот тип систем, которые вы используете для решения специфических задач. В этом смысле Redis близок к индексирующему движку. Вы не будете писать ваше приложение полностью на Lucene, но если вам нужна хорошая система поиска, она подарит вам полезный опыт.

На ум приходят следующие варианты использования Redis:

- Хранилище сессий и профилей пользователей;
- [Сервер очередей](https://metacpan.org/module/Redis::Queue), плюс держим в уме механизм publish/subscribe;
- Полноценная замена Memcached, притом в случае с Redis мы получим репликацию, более длинные ключи и значения, возможность восстановления кэша с диска и тп;
- Место для хранения [количества пользователей онлайн](http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/), кодов капч, различных флагов, саджестов поисковых запросов;
- СУБД для небольших приложений — сокращалок ссылок, имиджбордов, возможно даже блогов;
- Роль «словаря» в шардинге, то есть сервер, который знает, какие шарды на каких серверах искать;
- Хранилище промежуточных результатов вычислений при обработке больших объемов данных;

## Tarantool

Tarantool представляет собой решение, совмещающее неблокирующий сервер приложений на Lua с NoSQL базой данных. Высокой производительности позволяет достичь стек технологий, который использует тарантул:

- libev, libcoro и libeio для реализации event-loop'а, кооперативной многозадачности (coroutines/fibers) и асинхронной работы с сетью и другими задачами.
- LuaJIT — Трассирующий JIT-компилятор для Lua (на стероидах).

### Особенности хранилища

Базовым элементом хранения является кортеж. Кортеж имеет любую размерность, это просто произвольно длинный список полей, ассоциированный с уникальным ключом. Каждый кортеж принадлежит какому-то пространству (space). По полям кортежа можно определять индексы. Если проводить аналогии с реляционными СУБД, то "пространство" соответствует таблице, а "поля" соответствуют столбцам.

1. Несколько движков хранения данных:
   - Memtx — движок хранения данных полностью в памяти, с поддержкой нескольких видов индексов:
     - TREE (B+*-Дерево) — для быстрого поиска значений и возможности интегрирования.
     - HASH (Хеш-таблица) — для еще более быстрого поска значений.
     - BITSET (Битовая маска) — возможность поиска по битовым маскам.
     - RTREE (многомерное R*-Дерево) — для быстрого поиска близжайших соседей (KNN) и точек в заданных многомерных параллелепипедах с заданными функциями расстояния между двумя точками.
   - Sophia — двухуровневый движок хранения информации на диске, который был разработан в ответ на "недостатки" в LSM-деревьях, B-Деревьях и других. Он прекрасно подходит для нагрузки типа "много записи данных среднего размера и немного чтений", но расчёт идёт также на то, что чтение не будет занимать много времени.
2. Возможность поддерживать "персистентность" с помощью xlog (также известный как Transaction Log), snap (который, в свою очередь, является полным снимком БД) и eventual-consistency (консистетность в конечном счёте) master-master репликации.
3. Поддержка вторичных ключей и составных ключей.
4. Аутентификация и привелегии для пользователей и ролей.
5. MessagePack в качестве протокола для связи клиента с сервером и хранения информации внутри самой базы. MessagePack обеспечивает упаковку некоторых данных, что позволяет снизить траффик, передаваемый по сети, и размер занимаемой памяти в самом хранилище.
6. Поддержка транзакций и мультиверсионности индексов.

### Характеристика сервера приложений

Язык Lua прекрасно подходит для написания бизнес-логики вашего приложения и прост в освоении, а благодаря трассирующей JIT компиляции можно добиться существенной производительности. Также есть возможность писать модули приложения на языке C/C++.

Из встроенных библиотек есть возможность работы с YAML, JSON и CSV; имеется возможность для работы с неблокирующим дисковым/сетевым вводом-выводом, работой с UUID, алгоритмами хешированиями, упаковкой-распаковкой данных с заданной схемой и другое.

Имеется возможность связывать Tarantool'ы в кластера с помощью модуля 'net.box'. В качестве примера можно использовать модуль '[sharding](https://github.com/tarantool/shard)', который реализует шардинг на стороне сервера и '[connection-pool](https://github.com/tarantool/connection-pool)'.

## RabbitMQ

**RabbitMQ** — это распределенная система управления очередью сообщений. Распределенная, поскольку обычно работает как кластер узлов, где очереди распределяются по узлам и, опционально, реплицируются в целях устойчивости к ошибкам и высокой доступности. Штатно, она реализует AMQP 0.9.1 и предлагает другие протоколы, такие как STOMP, MQTT и HTTP через дополнительные модули.

RabbitMQ использует как классический, так и новаторский подходы к обмену сообщениями. Классический в том смысле, что она ориентирована на очередь сообщений, а новаторский — в возможности гибкой маршрутизации. Именно эта возможность маршрутизации является ее уникальным преимуществом. Создание быстрой, масштабируемой и надежной распределенной системы сообщений само по себе является достижением, но функциональность маршрутизации сообщений делает ее действительно выдающейся среди множества технологий обмена сообщениями.

### Exchange'и и очереди

Супер-упрощенный обзор:

- Паблишеры (publishers) отправляют сообщения на exchange’и
- Exchange’и отправляют сообщения в очереди и в другие exchange’и
- RabbitMQ отправляет подтверждения паблишерам при получении сообщения
- Получатели (consumers) поддерживают постоянные TCP-соединения с RabbitMQ и объявляют, какую очередь(-и) они получают
- RabbitMQ проталкивает (push) сообщения получателям
- Получатели отправляют подтверждения успеха/ошибки
- После успешного получения, сообщения удаляются из очередей

## Apache Kafka

Kafka — это распределенный реплицированный журнал фиксации изменений (commit log). У Kafka’и нет концепции очередей, что сначала может показаться странным, учитывая, что его используют в качестве системы обмена сообщениями. Очереди долгое время были синонимом систем обмена сообщениями. Давайте для начала разберемся, что значит «распределенный, реплицированный журнал фиксации изменений»:

- Распределенный, поскольку Kafka развертывается как кластер узлов, как для устойчивости к ошибкам, так и для масштабирования
- Реплицированный, поскольку сообщения обычно реплицируются на нескольких узлах (серверах).
- Журнал фиксации изменений, потому что сообщения хранятся в сегментированных, append-only журналах, которые называются топиками. Эта концепция журналирования является основным уникальным преимуществом Kafka’и.

 

*Дополнительно*:

https://stackoverflow.com/questions/10558465/memcached-vs-redis

https://habr.com/company/itsumma/blog/416629/ 

https://habr.com/company/mailru/blog/352760/

https://habr.com/company/oleg-bunin/blog/316652/