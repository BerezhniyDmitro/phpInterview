# Mysql

## Индексы

Индекс формируется из значений одного или нескольких столбцов таблицы и указателей на соответствующие строки таблицы и, таким образом, позволяет искать строки, удовлетворяющие критерию поиска. Ускорение работы с использованием индексов достигается в первую очередь за счёт того, что индекс имеет структуру, оптимизированную под поиск, например хэш таблицы или сбалансированные деревья.

Хеш-таблицам свойственны коллизии, когда для различных ключей получается одно и тоже хэш значение.

Некоторые общие принципы, связанные с созданием индексов:

- индексы необходимо создавать для столбцов, которые используются в джойнах, по которым часто производится поиск и операции сортировки. При этом необходимо учесть, что индексы всегда автоматически создаются для столбцов, на которые накладывается ограничение primary key. Чаще всего они создаются и для столбцов с foreign key;
- индекс обязательно в автоматическом режиме создается для столбцов, на которые наложено ограничение уникальности;
- лучше всего индексы создавать для тех полей, в которых - минимальное число повторяющихся значений и данные распределены равномерно.
- Если поиск постоянно производится по определенному набору столбцов (одновременно), то в этом случае, возможно, есть смысл создать композитный индекс - один индекс для группы столбцов;
- при внесении изменений в таблицы автоматически изменяются и индексы, наложенные на эту таблицу. В результате индекс может быть сильно фрагментирован, что сказывается на производительности. Периодически следует проверять степень фрагментации индексов и дефрагментировать их. При загрузке большого количества данных иногда есть смысл вначале удалить все индексы, а после завершения операции создать их заново;

## Типы индексов 

- B-Tree  

- R-Tree с квадратичным разбиением

- Hash index 

- Inverted index

- Function based index

  ​

## Движки таблиц MySql

- MyIsam
- InnoDB
- Memory
- Blackhole

**CSV**
хранит таблицы в CSV формате
позволяет редактировать таблицы внешними приложениями
плохо документирован, есть открытые баги


**FEDERATED**
Представляет собой «прозрачное» подключение к другому серверу (не репликация). Есть множество ограничений, планируется возможность подключения к отличным от MySQL серверам.

**BLACKHOLE**

Данные идут «вникуда», двоичные логи пишуться. Оптимизация репликации (мастер-сервер не пишет данные на диск)

##   

## Разное

### Explain

* id – порядковый номер для каждого SELECT’а внутри запроса (когда имеется несколько подзапросов)
* select_type – тип запроса SELECT.
  * SIMPLE — Простой запрос SELECT без подзапросов или UNION’ов
  * PRIMARY – данный SELECT – самый внешний запрос в JOIN’е
  * DERIVED – данный SELECT является частью подзапроса внутри FROM
  * SUBQUERY – первый SELECT в подзапросе
  * DEPENDENT SUBQUERY – подзапрос, который зависит от внешнего запроса
   * UNCACHABLE SUBQUERY – не кешируемый подзапрос (существуют определенные условия для того, чтобы запрос кешировался)
  * UNION – второй или последующий SELECT в UNION’е
  * DEPENDENT UNION – второй или последующий SELECT в UNION’е, зависимый от внешнего запроса
  * UNION RESULT – результат UNION’а
* Table – таблица, к которой относится выводимая строка
* Type — указывает на то, как MySQL связывает используемые таблицы. Это одно из наиболее полезных полей в выводе потому, что может сообщать об отсутствующих индексах или почему написанный запрос должен быть пересмотрен и переписан. Возможные значения:
  * System – таблица имеет только одну строку
  * Const – таблица имеет только одну соответствующую строку, которая проиндексирована. Это наиболее быстрый тип соединения потому, что таблица читается только один раз и значение строки может восприниматься при дальнейших соединениях   как константа.
  * Eq_ref – все части индекса используются для связывания. Используемые индексы: PRIMARY KEY или UNIQUE NOT NULL. Это еще один наилучший возможный тип связывания.
  * Ref – все соответствующие строки индексного столбца считываются для каждой комбинации строк из предыдущей таблицы. Этот тип соединения для индексированных столбцов выглядит как использование операторов = или < = >
  * Fulltext – соединение использует полнотекстовый индекс таблицы
  * Ref_or_null – то же самое, что и ref, но также содержит строки со значением null для столбца
  * Index_merge – соединение использует список индексов для получения результирующего набора. Столбец key вывода команды EXPLAIN будет содержать список использованных индексов.
  * Unique_subquery – подзапрос IN возвращает только один результат из таблицы и использует первичный ключ.
  * Index_subquery – тоже, что и предыдущий, но возвращает более одного результата.
  * Range – индекс, использованный для нахождения соответствующей строки в определенном диапазоне, обычно, когда ключевой столбец сравнивается с константой, используя операторы вроде: BETWEEN, IN, >, >=, etc.
  * Index – сканируется все дерево индексов для нахождения соответствующих строк.
  * All – Для нахождения соответствующих строк используются сканирование всей таблицы. Это наихудший тип соединения и обычно указывает на отсутствие подходящих индексов в таблице.
* Possible_keys – показывает индексы, которые могут быть использованы для нахождения строк в таблице. На практике они могут использоваться, а могут и не использоваться. Фактически, этот столбец может сослужить добрую службу в деле оптимизации запросов, т.к значение NULL указывает на то, что не найдено ни одного подходящего индекса .
* Key– указывает на использованный индекс. Этот столбец может содержать индекс, не указанный в столбце possible_keys. В процессе соединения таблиц оптимизатор ищет наилучшие варианты и может найти ключи, которые не отображены в possible_keys, но являются более оптимальными для использования.
* Key_len – длина индекса, которую оптимизатор MySQL выбрал для использования. Например, значение key_len, равное 4, означает, что памяти требуется для хранения 4 знаков. На эту тему вот cсылка
* Ref – указываются столбцы или константы, которые сравниваются с индексом, указанным в поле key. MySQL выберет либо значение константы для сравнения, либо само поле, основываясь на плане выполнения запроса.
* Rows – отображает число записей, обработанных для получения выходных данных. Это еще одно очень важное поле, которое дает повод оптимизировать запросы, особенно те, которые используют JOIN’ы и подзапросы.
* Extra – содержит дополнительную информацию, относящуюся к плану выполнения запроса. Такие значения как “Using temporary”, “Using filesort” и т.д могут быть индикатором проблемного запроса. С полным списком возможных значений вы можете ознакомиться здесь

https://habr.com/post/211022/


### Char & Varchar
При выборе типов строк действует правило минимума. Оцените максимальную длину строки и поставьте ограничение. Тип CHAR — тип фиксированной длины. Это значит, что для любой строки будет выделено всегда одно и то же количество байт.
VARCHAR — тип переменной длины. В такой колонке строка будет занимать ровно свою длину (в количестве символов).
Однако Mysql прибавит еще 1 или 2 байта на хранение длины самой строки. Также стоит учесть, что обновление такой строки может быть дорогой операцией (чревато фрагментацией данных, а значит — замедлением чтения). Используйте такое правило:

**Если значения в текстовой колонке похожи по длине, выбирайте CHAR, иначе — VARCHAR.**

## Innodv VS MyIsam

MyISAM поддерживает сжатие таблиц в отличии от InnoDB.
MyISAM имеет встроенные полнотекстный поиск в отличии от InnoDB.
InnoDB поддерживает транзакции в отличии от MyISAM.
InnoDB поддерживает блокировки уровня строки (MyISAM - только уровня таблицы).
InnoDB поддерживает ограничения внешних ключей (MyISAM - нет).
InnoDB более надежна при больших объемах данных.
InnoDB в теории немного быстрее.

<table border="1" width="100%" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="65%">Описание</td>
<td width="15%"><strong>MyISAM</strong></td>
<td width="20%"><strong>InnoDB</strong></td>
</tr>
<tr>
<td><strong>Транзакционный движек?</strong>Транзакция (Transaction) — блок операторов SQL , который в случае ошибки в одном запросе, возвращается к предыдущему состоянию (Rollback), и только в случае выполнения всех запросов подтверждается (Commit)</td>
<td>Нет</td>
<td>Да</td>
</tr>
<tr>
<td><strong>Поддержка внешних ключей</strong>Внешние ключи — это способ связать записи в двух таблицах по определенным полям так, что при обновлении поля в родительской автоматически происходит определенное изменение поля в дочерней (дочернюю и родительскую выбираешь при создании ключа; точнее, создаешь ключ в дочерней, который ссылается на родительскую).</td>
<td>Нет</td>
<td>Да</td>
</tr>
<tr>
<td><strong>Блокировка.</strong>Блокировка на уровне строк, т.е. если процессу нужно обновить строку в таблице, то он блокирует только эту строку, позволяя другим обновлять другие строки параллельно</td>
<td>Блокировка на уровне таблиц</td>
<td>Блокировка на уровне строк</td>
</tr>
<tr>
<td>Одновременные запросы к разным частям таблицы.</td>
<td>Медленнее</td>
<td>Быстрее</td>
</tr>
<tr>
<td>При смешанной нагрузке в таблице (select/update/delete/insert)</td>
<td>Медленнее</td>
<td>Быстрее</td>
</tr>
<tr>
<td>Операция Insert</td>
<td>Быстрее</td>
<td>Медленнее, ибо есть оверхед на транзакцию, но это цена надежности</td>
</tr>
<tr>
<td>Если преобладают операции чтения (SELECT)</td>
<td>Работает быстрее</td>
<td>Работает медленнее</td>
</tr>
<tr>
<td><strong>Deadlock</strong>Deadlock — ситуация в многозадачной среде или СУБД, при которой несколько процессов находятся в состоянии бесконечного ожидания ресурсов, захваченных самими этими процессами.</td>
<td>Не возникают</td>
<td>Возможны.</td>
</tr>
<tr>
<td>Поддержка полнотекстового поиска</td>
<td>Да</td>
<td>Нет (доступен начиная с версии MySQL 5.6.4)</td>
</tr>
<tr>
<td>Запрос Count(*)</td>
<td>Быстрее</td>
<td>Медленнее</td>
</tr>
<tr>
<td><strong>Поддержка mysqlhotcopy</strong>Утилита mysqlhotcopy представляет собой Perl-сценарий, использующий SQL-команды LOCK TABLES, FLUSH TABLES и Unix-утилиты cp или scp для быстрого получения резервной копии базы данных.</td>
<td>Да</td>
<td>Нет</td>
</tr>
<tr>
<td>Файловое хранение таблиц</td>
<td>Каждой таблице отдельный файл</td>
<td>Данные при настройках по умолчанию хранятся в больших совместно используемых файлах</td>
</tr>
<tr>
<td><strong>Бинарное копировании таблиц?</strong>Табличные файлы можно перемещать между компьютерами разных архитектур и разными операционными системами без всякого преобразования.</td>
<td>Да</td>
<td>Нет</td>
</tr>
<tr>
<td>Размер таблиц в БД</td>
<td>Меньше</td>
<td>Больше</td>
</tr>
<tr>
<td>Поведение в случае сбоя</td>
<td>Крашится вся таблица</td>
<td>По логам можно все восстановить</td>
</tr>
<tr>
<td>В случае хранения «логов» и подобного</td>
<td>Лучше</td>
<td>Хуже</td>
</tr>
</tbody>
</table>

##  Join

![](media/image6.jpeg)


## Полезные ресурсы:
* https://ruhighload.com/%D0%92%D1%8B%D0%B1%D0%BE%D1%80+%D1%82%D0%B8%D0%BF%D0%BE%D0%B2+%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85+%D0%B2+mysql
* https://itif.ru/otlichiya-myisam-innodb/
