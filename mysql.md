# Mysql

## Индексы

Индекс формируется из значений одного или нескольких столбцов таблицы и указателей на соответствующие строки таблицы и, таким образом, позволяет искать строки, удовлетворяющие критерию поиска. Ускорение работы с использованием индексов достигается в первую очередь за счёт того, что индекс имеет структуру, оптимизированную под поиск, например хэш таблицы или сбалансированные деревья.

Хеш-таблицам свойственны коллизии, когда для различных ключей получается одно и тоже хэш значение.

Некоторые общие принципы, связанные с созданием индексов:

- индексы необходимо создавать для столбцов, которые используются в джойнах, по которым часто производится поиск и операции сортировки. При этом необходимо учесть, что индексы всегда автоматически создаются для столбцов, на которые накладывается ограничение primary key. Чаще всего они создаются и для столбцов с foreign key;
- индекс обязательно в автоматическом режиме создается для столбцов, на которые наложено ограничение уникальности;
- лучше всего индексы создавать для тех полей, в которых - минимальное число повторяющихся значений и данные распределены равномерно.
- Если поиск постоянно производится по определенному набору столбцов (одновременно), то в этом случае, возможно, есть смысл создать композитный индекс - один индекс для группы столбцов;
- при внесении изменений в таблицы автоматически изменяются и индексы, наложенные на эту таблицу. В результате индекс может быть сильно фрагментирован, что сказывается на производительности. Периодически следует проверять степень фрагментации индексов и дефрагментировать их. При загрузке большого количества данных иногда есть смысл вначале удалить все индексы, а после завершения операции создать их заново;

## Типы индексов 

- B-Tree  

- R-Tree с квадратичным разбиением

- Hash index	 

- Inverted index	

- Function based index

  ​

## Движки таблиц MySql

- MyIsam
- InnoDB
- Memory
- Blackhole

##   

##  

##  

## Разное

### Explain

* id – порядковый номер для каждого SELECT’а внутри запроса (когда имеется несколько подзапросов)
* select_type – тип запроса SELECT.
  * SIMPLE — Простой запрос SELECT без подзапросов или UNION’ов
  * PRIMARY – данный SELECT – самый внешний запрос в JOIN’е
  * DERIVED – данный SELECT является частью подзапроса внутри FROM
  * SUBQUERY – первый SELECT в подзапросе
  * DEPENDENT SUBQUERY – подзапрос, который зависит от внешнего запроса
   * UNCACHABLE SUBQUERY – не кешируемый подзапрос (существуют определенные условия для того, чтобы запрос кешировался)
  * UNION – второй или последующий SELECT в UNION’е
  * DEPENDENT UNION – второй или последующий SELECT в UNION’е, зависимый от внешнего запроса
  * UNION RESULT – результат UNION’а
* Table – таблица, к которой относится выводимая строка
* Type — указывает на то, как MySQL связывает используемые таблицы. Это одно из наиболее полезных полей в выводе потому, что может сообщать об отсутствующих индексах или почему написанный запрос должен быть пересмотрен и переписан. Возможные значения:
  * System – таблица имеет только одну строку
  * Const – таблица имеет только одну соответствующую строку, которая проиндексирована. Это наиболее быстрый тип соединения потому, что таблица читается только один раз и значение строки может восприниматься при дальнейших соединениях   как константа.
  * Eq_ref – все части индекса используются для связывания. Используемые индексы: PRIMARY KEY или UNIQUE NOT NULL. Это еще один наилучший возможный тип связывания.
  * Ref – все соответствующие строки индексного столбца считываются для каждой комбинации строк из предыдущей таблицы. Этот тип соединения для индексированных столбцов выглядит как использование операторов = или < = >
  * Fulltext – соединение использует полнотекстовый индекс таблицы
  * Ref_or_null – то же самое, что и ref, но также содержит строки со значением null для столбца
  * Index_merge – соединение использует список индексов для получения результирующего набора. Столбец key вывода команды EXPLAIN будет содержать список использованных индексов.
  * Unique_subquery – подзапрос IN возвращает только один результат из таблицы и использует первичный ключ.
  * Index_subquery – тоже, что и предыдущий, но возвращает более одного результата.
  * Range – индекс, использованный для нахождения соответствующей строки в определенном диапазоне, обычно, когда ключевой столбец сравнивается с константой, используя операторы вроде: BETWEEN, IN, >, >=, etc.
  * Index – сканируется все дерево индексов для нахождения соответствующих строк.
  * All – Для нахождения соответствующих строк используются сканирование всей таблицы. Это наихудший тип соединения и обычно указывает на отсутствие подходящих индексов в таблице.
* Possible_keys – показывает индексы, которые могут быть использованы для нахождения строк в таблице. На практике они могут использоваться, а могут и не использоваться. Фактически, этот столбец может сослужить добрую службу в деле оптимизации запросов, т.к значение NULL указывает на то, что не найдено ни одного подходящего индекса .
* Key– указывает на использованный индекс. Этот столбец может содержать индекс, не указанный в столбце possible_keys. В процессе соединения таблиц оптимизатор ищет наилучшие варианты и может найти ключи, которые не отображены в possible_keys, но являются более оптимальными для использования.
* Key_len – длина индекса, которую оптимизатор MySQL выбрал для использования. Например, значение key_len, равное 4, означает, что памяти требуется для хранения 4 знаков. На эту тему вот cсылка
* Ref – указываются столбцы или константы, которые сравниваются с индексом, указанным в поле key. MySQL выберет либо значение константы для сравнения, либо само поле, основываясь на плане выполнения запроса.
* Rows – отображает число записей, обработанных для получения выходных данных. Это еще одно очень важное поле, которое дает повод оптимизировать запросы, особенно те, которые используют JOIN’ы и подзапросы.
* Extra – содержит дополнительную информацию, относящуюся к плану выполнения запроса. Такие значения как “Using temporary”, “Using filesort” и т.д могут быть индикатором проблемного запроса. С полным списком возможных значений вы можете ознакомиться здесь

https://habr.com/post/211022/


### Char & Varchar
При выборе типов строк действует правило минимума. Оцените максимальную длину строки и поставьте ограничение. Тип CHAR — тип фиксированной длины. Это значит, что для любой строки будет выделено всегда одно и то же количество байт.
VARCHAR — тип переменной длины. В такой колонке строка будет занимать ровно свою длину (в количестве символов).
Однако Mysql прибавит еще 1 или 2 байта на хранение длины самой строки. Также стоит учесть, что обновление такой строки может быть дорогой операцией (чревато фрагментацией данных, а значит — замедлением чтения). Используйте такое правило:

**Если значения в текстовой колонке похожи по длине, выбирайте CHAR, иначе — VARCHAR.**

##  Join

![](media/image6.jpeg)


## Полезные ресурсы:
* https://ruhighload.com/%D0%92%D1%8B%D0%B1%D0%BE%D1%80+%D1%82%D0%B8%D0%BF%D0%BE%D0%B2+%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85+%D0%B2+mysql
